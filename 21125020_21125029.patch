diff --git a/Makefile b/Makefile
index 365c91b..c5697b0 100644
--- a/Makefile
+++ b/Makefile
@@ -188,7 +188,11 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
-
+	$U/_sleep\
+	$U/_pingpong\
+	$U/_primes\
+	$U/_find\
+	$U/_xargs\
 
 
 
diff --git a/time.txt b/time.txt
new file mode 100644
index 0000000..62f9457
--- /dev/null
+++ b/time.txt
@@ -0,0 +1 @@
+6
\ No newline at end of file
diff --git a/user/find.c b/user/find.c
new file mode 100644
index 0000000..634ba21
--- /dev/null
+++ b/user/find.c
@@ -0,0 +1,67 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "kernel/fcntl.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+
+char* fmtname(char *path) {
+    char *p;
+
+    // Find first character after last slash.
+    for(p=path+strlen(path); p >= path && *p != '/'; p--);
+    p++;
+
+    return p;
+}
+
+void find(char *path, char *name) {
+    char buf[512], *p;
+    int fd;
+    struct dirent de;
+    struct stat st;
+
+    if((fd = open(path, 0)) < 0) {
+        fprintf(2, "find: cannot open %s\n", path);
+        return;
+    }
+
+    if(fstat(fd, &st) < 0) {
+        fprintf(2, "find: cannot stat %s\n", path);
+        close(fd);
+        return;
+    }
+
+    switch(st.type) {
+        case T_FILE:
+            if(strcmp(name, fmtname(path)) == 0)
+                fprintf(1, "%s\n", path);
+            break;
+
+        case T_DIR:
+            if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf) {
+                fprintf(1, "find: path too long\n");
+                break;
+            }
+            strcpy(buf, path);
+            p = buf+strlen(buf);
+            *p++ = '/';
+            while(read(fd, &de, sizeof(de)) == sizeof(de)) {
+                if(de.inum == 0 || strcmp(de.name, ".") == 0 || strcmp(de.name, "..") == 0)
+                    continue;
+                memmove(p, de.name, DIRSIZ);
+                p[DIRSIZ] = 0;
+                find(buf, name);
+            }
+            break;
+    }
+    close(fd);
+}
+
+int main(int argc, char *argv[]) {
+    if(argc != 3) {
+        fprintf(2, "Usage: find [path] [filename]\n");
+        exit(1);
+    }
+    find(argv[1], argv[2]);
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/pingpong.c b/user/pingpong.c
new file mode 100644
index 0000000..d43ec66
--- /dev/null
+++ b/user/pingpong.c
@@ -0,0 +1,24 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int main(int argc, char *argv[])
+{
+    int p[2];
+    pipe(p);
+    if (fork() == 0)
+    {
+        char c;
+        read(p[0], &c, 1);
+        printf("%d: received ping\n", getpid());
+        write(p[1], "y", 1);
+    }
+    else
+    {
+        write(p[1], "x", 1);
+        char c;
+        read(p[0], &c, 1);
+        printf("%d: received pong\n", getpid());
+    }
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/primes.c b/user/primes.c
new file mode 100644
index 0000000..2b832e4
--- /dev/null
+++ b/user/primes.c
@@ -0,0 +1,54 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "kernel/fcntl.h"
+#include "user/user.h"
+
+void prime(int *p) {
+  int n;
+  close(p[1]);
+  if (read(p[0], &n, sizeof(n)) < sizeof(n)) {
+    close(p[0]);
+    return;
+  }
+  fprintf(1, "prime %d\n", n);
+  int q[2];
+  if (pipe(q) < 0) {
+    fprintf(1, "pipe failed\n");
+    exit(0);
+  }
+  if (fork() == 0) {
+    close(p[0]);
+    prime(q);
+  } else {
+    close(q[0]);
+    int i;
+    while (read(p[0], &i, sizeof(i)) == sizeof(i)) {
+      if (i % n != 0) {
+        write(q[1], &i, sizeof(i));
+      }
+    }
+    close(p[0]);
+    close(q[1]);
+    wait((int*)0);
+  }
+}
+
+int main(int argc, char *argv[]) {
+  int p[2];
+  if (pipe(p) < 0) {
+    fprintf(1, "pipe failed\n");
+    exit(1);
+  }
+  if (fork() == 0) {
+    for (int i = 2; i <= 35; i++) {
+      write(p[1], &i, sizeof(i));
+    }
+    close(p[1]); 
+    exit(0);
+  } else {
+    close(p[1]);
+    prime(p);
+    wait((int*)0);
+  }
+  exit(0);
+}
\ No newline at end of file
diff --git a/user/sleep.c b/user/sleep.c
new file mode 100644
index 0000000..afc94a7
--- /dev/null
+++ b/user/sleep.c
@@ -0,0 +1,14 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int main(int argc, char *argv[])
+{
+    if (argc < 2)
+    {
+        fprintf(2, "Forget to pass argument\n");
+        exit(1);
+    }
+    sleep(atoi(argv[1]));
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/xargs.c b/user/xargs.c
new file mode 100644
index 0000000..e382efb
--- /dev/null
+++ b/user/xargs.c
@@ -0,0 +1,78 @@
+#include "kernel/types.h"
+#include "user/user.h"
+#include "kernel/fcntl.h"
+#include "kernel/param.h"
+
+#define MAX_LEN 1024
+
+void getCmdArguments(char **preArgv, int preArgc, char *newArgv, char **argv)
+{
+    int k = 0;
+    for (int i = 0; i < preArgc; i++)
+    {
+        argv[k] = malloc(strlen(preArgv[i]) + 1);
+        memcpy(argv[k++], preArgv[i], strlen(preArgv[i]) + 1);
+    }
+    argv[k] = malloc(strlen(newArgv) + 1);
+    memcpy(argv[k++], newArgv, strlen(newArgv) + 1);
+}
+
+int main(int argc, char *argv[])
+{
+    if (argc < 2)
+    {
+        fprintf(2, "Forget to pass argument\n");
+        exit(1);
+    }
+
+    char lstArg[MAX_LEN];
+    int i = 0;
+    char curChar;
+    int isValid = 0;
+
+    while (read(0, &curChar, 1) > 0)
+    {
+        if (curChar == '\n')
+        {
+            if (isValid)
+            {
+                i = 0;
+                isValid = 0;
+                continue;
+            }
+            lstArg[i] = 0;
+            i = 0;
+
+            int pid = fork();
+            if (pid == 0)
+            {
+                int curArgc = argc;
+                char *curArgv[MAXARG];
+
+                getCmdArguments(argv + 1, argc - 1, lstArg, curArgv);
+                curArgv[curArgc] = 0;
+
+                exec(curArgv[0], curArgv);
+                exit(0);
+            }
+            else
+            {
+                wait((int *)0);
+            }
+        }
+        else
+        {
+            if (!isValid && i >= MAX_LEN - 1)
+            {
+                isValid = 1;
+                printf("Too many arguments...\n");
+            }
+            if (!isValid)
+            {
+                lstArg[i++] = curChar;
+            }
+        }
+    }
+
+    exit(0);
+}
\ No newline at end of file
